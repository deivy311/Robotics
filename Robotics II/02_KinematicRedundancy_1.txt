Robotics 2

Robots with
kinematic redundancy
Part 1: Fundamentals
Prof. Alessandro De Luca

Redundant robots
n

direct kinematics of the task ğ‘Ÿ = ğ‘“(ğ‘)

ğ‘“: Q Â® R
joint space (dim Q = ğ‘ )
n

task space (dim R = ğ‘€ )

a robot is (kinematically) redundant for the task if ğ‘ > ğ‘€
(more degrees of freedom than strictly needed for executing the task)

n

n

ğ‘Ÿ may contain the position and/or the orientation of the

end-effector or, more in general, be any parameterization
of the task (even not in the Cartesian workspace)
â€œredundancyâ€ of a robot is thus a relative concept, i.e., it
holds with respect to a given task

Robotics 2

2

Some E-E tasks and their dimensions
TASKS [for the robot end-effector (E-E)]
n
n
n
n
n

dimension ğ‘€

position in the plane
position in 3D space
orientation in the plane
pointing in 3D space
position and orientation in 3D space

2
3
1
2
6

a planar robot with ğ‘ = 3 joints is redundant for the task
of positioning its E-E in the plane (ğ‘€ = 2), but NOT for the
task of positioning AND orienting the E-E in the plane (ğ‘€ = 3)

Robotics 2

3

Typical cases of redundant robots
n

6R robot mounted on a linear track/rail
n

n

7 dofs for positioning and orienting its end-effector in 3D space

6-dof robot used for arc welding tasks
n

task does not prescribe the final roll angle of the welding gun

n

dexterous robotic hands
multiple cooperating manipulators
manipulator on a mobile base
humanoid robots, team of mobile robots ...

n

â€œkinematicâ€ redundancy is not the only typeâ€¦

n
n
n

n
n

Robotics 2

redundancy of components (actuators, sensors)
redundancy in the control/supervision architecture

4

Uses of robot redundancy
n
n
n
n
n
n
n
n
n

avoid collision with obstacles (in Cartesian space) â€¦
â€¦ or kinematic singularities (in joint space)
stay within the admissible joint ranges
increase manipulability in specified directions
uniformly distribute/limit joint velocities and/or accelerations
minimize energy consumption or needed motion torques
optimize execution time
increase dependability with respect to faults
...
all objectives should be
quantitatively â€œmeasurableâ€

Robotics 2

5

DLR robots: LWR-III and Justin

Justin two-arm upper-body humanoid:
43R actuated =
two arms (2Ã—7) + torso (3*)
7R LWR-III lightweight manipulator:
elastic joints (HD), joint torque sensing, + head (2) + two hands (2Ã—12),
45 kg weight
13.5 kg weight = payload
Robotics 2

* = one joint is dependent on the motion of the other two

6

Justin carrying a trailer
video

motion planning for DLR Justin robot in the configuration space,
avoiding Cartesian obstacles and using robot redundancy
Robotics 2

7

Dual-arm redundancy
video

DIS, Uni Napoli
two 6R Comau robots, one mounted on a linear track (+1P)
coordinated 6D motion using the null-space of the right-side robot (ğ‘ âˆ’ ğ‘€ = 1)
Robotics 2

8

Motion cueing from redundancy
video

Max Planck Institute for Biological Cybernetics, TÃ¼bingen
a 6R KUKA KR500 mounted on a linear track (+1P) with a sliding cabin (+1R),
used as a dynamic emulation platform for human perception (ğ‘ âˆ’ ğ‘€ = 2)
Robotics 2

9

Self-motion
video

video

Nakamuraâ€™s Lab, Uni Tokyo
8R Dexter: self-motion with
constant 6D pose of E-E (ğ‘ âˆ’ ğ‘€ = 2)
Robotics 2

6R robot with spherical shoulder
in compliant tasks for the
Cartesian E-E position (ğ‘ âˆ’ ğ‘€ = 3)
10

Obstacle avoidance
video

6R planar arm moving on a given geometric path for the E-E (ğ‘ âˆ’ ğ‘€ = 4)
Robotics 2

11

Disadvantages of redundancy
n

potential benefits should be traded off against
n

n

a greater structural complexity of construction
n

mechanical (more links, transmissions, ...)

n

more actuators, sensors, ...

n

costs

more complicated algorithms for inverse kinematics
and motion control

Robotics 2

12

Inverse kinematics problem
n

find ğ‘(ğ‘¡) that realizes the task: ğ‘“ ğ‘ ğ‘¡

n

infinite solutions exist when the robot is redundant
(even for ğ‘Ÿ(ğ‘¡) = ğ‘Ÿ = constant)
ğ‘=3>2=ğ‘€

n

n

ğ‘Ÿ = constant
E-E position

the robot arm may have â€œinternal displacementsâ€ that are
unobservable at the task level (e.g., not contributing to E-E motion)
n

n

= ğ‘Ÿ(ğ‘¡) (at all times ğ‘¡)

these joint displacements can be chosen so as to improve/optimize
in some way the behavior of the robotic system

self-motion: an arm reconfiguration in the joint space that
does not change/affect the value of the task variables ğ‘Ÿ
solutions are mainly sought at differential level (e.g., velocity)

Robotics 2

13

Redundancy resolution

via optimization of an objective function

Local methods
given ğ‘Ÿ(ğ‘¡)
Ì‡
and ğ‘(ğ‘¡), ğ‘¡ = ğ‘˜ğ‘‡ğ‘ 
optimization of ğ»(ğ‘, ğ‘)
Ì‡

ğ‘(ğ‘˜ğ‘‡
Ì‡
C)

Global methods
given ğ‘Ÿ(ğ‘¡), ğ‘¡ âˆˆ [ğ‘¡7 , ğ‘¡7 + ğ‘‡], ğ‘(ğ‘¡0)
>? @A
optimization of âˆ«>
ğ»(ğ‘, ğ‘)ğ‘‘ğ‘¡
Ì‡
?

ON-LINE

ğ‘ ğ‘˜ + 1 ğ‘‡C = ğ‘ ğ‘˜ğ‘‡C + ğ‘‡C ğ‘Ì‡ ğ‘˜ğ‘‡C

ğ‘(ğ‘¡), ğ‘¡ âˆˆ [ğ‘¡7 , ğ‘¡7 + ğ‘‡]
OFF-LINE

discrete-time form

Robotics 2

relatively EASY
(a LQ problem)

quite DIFFICULT
(nonlinear TPBV problems arise)

14

Local resolution methods
three classes of methods for solving ğ‘ŸÌ‡ = ğ½(ğ‘)ğ‘Ì‡
1n Jacobian-based methods (here, analytic Jacobian in general!)
among the infinite solutions, one is chosen, e.g., that minimizes a
suitable (possibly weighted) norm
2n null-space methods
a term is added to the previous solution so as not to affect execution
of the task trajectory, i.e., belonging to the null-space ğ’©(ğ½ ğ‘ )
3n task augmentation methods
redundancy is reduced/eliminated by adding ğ‘† â‰¤ ğ‘ âˆ’ ğ‘€ further
auxiliary tasks (when ğ‘† = ğ‘ âˆ’ ğ‘€ , the problem has been â€œsquaredâ€)

ğ‘Ÿ = ğ‘“(ğ‘)
Robotics 2

ğ‘ŸÌ‡ = ğ½(ğ‘)ğ‘Ì‡
15

1

Jacobian-based methods

we look for a solution to ğ‘ŸÌ‡ = ğ½ ğ‘ ğ‘Ì‡ in the form
ğ½=

ğ‘€
ğ‘

ğ‘Ì‡ = ğ¾ ğ‘ ğ‘ŸÌ‡

ğ¾=

ğ‘
ğ‘€

minimum requirement for ğ¾: ğ½ ğ‘ ğ¾ ğ‘ ğ½ ğ‘ = ğ½(ğ‘)
(
ğ¾ = generalized inverse of ğ½)

âˆ€ğ‘ŸÌ‡ âˆˆ â„›(ğ½ ğ‘ )

ğ½ ğ‘ ğ¾(ğ‘)ğ‘ŸÌ‡ = ğ½ ğ‘ ğ¾ ğ‘ ğ½ ğ‘ ğ‘Ì‡ = ğ½ ğ‘ ğ‘Ì‡ = ğ‘ŸÌ‡

example:
LM
ğ½
I
if ğ½ = ğ½I ğ½J , det(ğ½I ) Â¹ 0, one such generalized inverse of ğ½ is ğ¾K =
0
(actually, this is a stronger right-inverse)
Robotics 2

16

Pseudoinverse
ğ‘Ì‡ = ğ½# (ğ‘)ğ‘ŸÌ‡
n

ğ½# always exists, and is the unique matrix satisfying
ğ½# ğ½ ğ½# = ğ½#
ğ½ ğ½# ğ½ = ğ½
ğ½ğ½

n

... a very common choice: ğ¾ = ğ½#

# A

=ğ½ğ½

#

ğ½#

ğ½

A

= ğ½# ğ½

if ğ½ is full (row) rank, ğ½# = ğ½A ğ½ ğ½A LM ; else, it is computed
numerically using the SVD (Singular Value Decomposition) of ğ½
(pinv of Matlab)

n

n

the pseudo-inverse joint velocity is the only that minimizes the
norm ğ‘Ì‡ Q = ğ‘Ì‡ A ğ‘Ì‡ among all joint velocities that minimize the
task error norm ğ‘ŸÌ‡ âˆ’ ğ½(ğ‘)ğ‘Ì‡ Q
if the task is feasible (ğ‘ŸÌ‡ âˆˆ â„› ğ½(ğ‘) ), there will be no task error

Robotics 2

17

Weighted pseudoinverse
# ğ‘ ğ‘ŸÌ‡
ğ‘Ì‡ = ğ½R

#
another choice: ğ¾ = ğ½R

n

#
if ğ½ is full (row) rank, ğ½R
= ğ‘Š LM ğ½A ğ½ğ‘Š LM ğ½A

n

the solution ğ‘Ì‡ minimizes the weighted norm
ğ‘Ì‡

n

Q
R

= ğ‘Ì‡ A ğ‘Š ğ‘Ì‡

LM

ğ‘Š > 0, symmetric
(often diagonal)

large weight ğ‘Šğ‘– â‡’ small ğ‘Ì‡ V (e.g., weights can be

chosen proportionally to the inverse of the joint ranges)
n

it is NOT a â€œpseudoinverseâ€ (4th relation does not
hold ...) but shares similar properties

Robotics 2

18

Singular Value Decomposition (SVD)
n

the SVD routine of Matlab applied to ğ½ provides two orthonormal
matrices ğ‘ˆXÃ—X and ğ‘‰[Ã—[ , and a matrix Î£XÃ—[ of the form
ğœM
ğœM â‰¥ ğœQ â‰¥ â‹¯ â‰¥ ğœb > 0
ğœQ
ğœb@M = â‹¯ = ğœX = 0
Î£=
0XÃ—([LX)
â‹±
singular values of ğ½
ğœX
where ğœŒ = rank(ğ½) â‰¤ ğ‘€, so that their product is

ğ½ = ğ‘ˆÎ£ğ‘‰ A
n

n

the columns of ğ‘ˆ are eigenvectors of ğ½ ğ½ğ‘‡ (associated to its nonnegative eigenvalues ğœğ‘–2), the columns of ğ‘‰ are eigenvectors of ğ½ğ‘‡ğ½
the last ğ‘ âˆ’ ğœŒ columns of ğ‘‰ are a basis for the null space of ğ½

ğ½ğ‘£V = ğœV ğ‘¢V (i = 1, â‹¯ , ğœŒ)
Robotics 2

ğ½ğ‘£V = 0 (i = Ï + 1, â‹¯ , ğ‘)
19

Computation of pseudoinverses
n

show that the pseudoinverse of ğ½ is equal to

ğ½ = ğ‘ˆÎ£ğ‘‰ A

ğ½# = ğ‘‰Î£ # ğ‘ˆ A

â‡’

Î£# =

â‹±

1
ğœb

0(XLb)Ã—(XLb)
_______________________________
0([LX)Ã—X

for any rank ğœŒ of ğ½
n

1
ğœM

#
show that matrix ğ½R
appears when solving the constrained linearquadratic (LQ) optimization problem (with ğ‘Š > 0, symmetric, and
assuming ğ½ of full rank)

min

M
Q

ğ‘Ì‡

Q
R

s.t.

ğ½ ğ‘ ğ‘Ì‡ âˆ’ ğ‘ŸÌ‡ = 0

and that the pseudoinverse is a particular case for ğ‘Š = ğ¼
n

show that a weighted pseudoinverse of J can be computed by
SVD/pinv as
#
ğ½R
= ğ‘Š LM/Q pinv(ğ½ğ‘ğ‘¢ğ‘¥ )
ğ½Imn = ğ½ğ‘Š LM/Q

Robotics 2

20

Singularity robustness

applies equally to
square and non-square
matrices

unconstrained
minimization
of a suitable
objective function

SOLUTION
n

Damped Least Squares (DLS)

min ğ» ğ‘Ì‡
uÌ‡

vw
=
Q

ğ‘Ì‡

Q

+

M
â€–ğ‘ŸÌ‡
Q

âˆ’

ğ½ğ‘â€–
Ì‡ Q

ğ‘Ì‡ = ğ½yz{ ğ‘ ğ‘ŸÌ‡ = ğ½A ğ½ ğ½A + ğœ‡Q ğ¼X

compromise between
large joint velocity
and task accuracy

LM ğ‘ŸÌ‡

induces a robust behavior when crossing singularities, but in its basic
version gives always a task error ğ‘’Ì‡ = ğœ‡Q ğ½ ğ½A + ğœ‡Q ğ¼X LM ğ‘ŸÌ‡ (as in the ğ‘ = ğ‘€ case)
n

ğ½ğ·ğ¿ğ‘† is not a generalized inverse ğ¾

n

using SVD: ğ½ = ğ‘ˆ Î£ ğ‘‰ğ‘‡ â‡’ ğ½yz{ = ğ‘‰Î£yz{ ğ‘ˆ A , Î£yz{ =

n

n

ğœV
ğœVQ + ğœ‡Q
0(XLb)Ã—(XLb)
ğœŒÃ—ğœŒ
____________________________________
0([LX)Ã—b
0([LX)Ã—(XLb)
ğ‘‘ğ‘–ğ‘ğ‘”

choice of a variable damping factor ğœ‡2(ğ‘) â‰¥ 0, as a function of the
minimum singular value ğœğ‘š(ğ‘) of ğ½ â‰… measure of distance to singularity
numerical filtering: introduces damping only/mostly in non-feasible
directions for the task (see Maciejewski and Klein, J of Rob Syst, 1988)

Robotics 2

21

Behavior of DLS solution
a. comparison of joint velocity norm with
PINV (pseudoinverse) or DLS solutions
â€¢ in a direction of a singular vector ğ‘¢ , when
the associated singular value ğœ âŸ¶ 0
â€¢ PINV goes to infinity (and then is 0 at ğœ = 0)
â€¢ DLS peaks a value of 1/2ğœ‡ at ğœ = ğœ‡ (and then
smoothly goes to 0...)
b. graphical interpretation of â€œdampingâ€ effect (here ğ‘€ = ğ‘ = 2, for simplicity)
one equality
constraint
minimum norm
solution

Robotics 2

two equality
constraints

exact (unique)
solution

two (almost dependent)
equality constraints

approximate
(damped) solution

ğœ‡Q
ğ»(ğ‘)
Ì‡ =
ğ‘Ì‡
2

exact (ill-conditioned)
solution

Q

1
+ ğ‘ŸÌ‡ âˆ’ ğ½ğ‘Ì‡
2

Q

22

Numerical example of DLS solution
planar 2R arm, unit links, close to (stretched) singular configuration ğ‘1 = 45Â°, ğ‘2 = 1.5Â°)
ğ‘Ì‡ yz{ =

.472
.055

(ğœ‡2 = 10-3)

ğ‘Ì‡ yz{ =

.133
.066

(ğœ‡2 = 10)

ğ‘ŸÌ‡ =

âˆ’1/ 2

1/ 2
âˆˆ â„›(ğ½) even
@singularity!

(âˆ â† Âµ)
â†’
(Âµ
0)

1
ğ‘Ì‡ âˆ— =
âˆ’1

ğœ‡Q

1
Q
ğ»=
ğ‘Ì‡ + ğ‘ŸÌ‡ âˆ’ ğ½ğ‘Ì‡
2
2

Robotics 2

Âµ2
Q

0

1
ğ‘Ì‡ =
âˆ’1

iso-level
curves of H

âˆ—

exact
solution
(Âµ=0)

10-4

10-3

10-2

10

â€–ğ‘â€–
Ì‡ âˆš2
â€–ğ‘’â€–
Ì‡
0

.8954

.4755

.4467

.1490

6.6â‹…10-3

1.4â‹…10-2

1.6â‹…10-2

.6668

Hmin

7.7â‹…10-5

2.2â‹…10-4

1.2â‹…10-3

3.4â‹…10-1

0

23

Limits of Jacobian-based methods
n

no guarantee that singularities are globally avoided during
task execution
n

n

despite joint velocities are kept to a minimum, this is only a local
property and â€œavalancheâ€ phenomena may occur

typically lead to non-repeatable motion in the joint space
n

cyclic motions in task space do not map to cyclic motions in joint space
after
1 tour

qfin Â¹ qin

qin = q(0)
>

ğ‘ ğ‘¡ = ğ‘(0) + â€¡ ğ¾ ğ‘ ğœ ğ‘ŸÌ‡ ğœ ğ‘‘ğœ
Robotics 2

7

24

Drift with Jacobian pseudoinverse
n
n

n

a 7R KUKA LWR4 robot moves in the vicinity of a human operator
we command a cyclic Cartesian path (only in position, ğ‘€ = 3), to be
repeated several times using the pseudoinverse solution
(unexpected) collision of a link occurs during the third cycle ...
video

Robotics 2

25

2

Null-space methods

general solution of ğ½ğ‘Ì‡ = ğ‘ŸÌ‡

ğ‘Ì‡ =

ğ½# ğ‘ŸÌ‡

+

a particular solution
(here, the pseudoinverse)
in â„›(ğ½A )

all solutions of the associated
ğ¼
ğ‘Ì‡ 7
homogeneous equation ğ½ğ‘Ì‡ = 0
(self-motions)
â€œorthogonalâ€ projection
of ğ‘Ì‡ 0 in ğ’©(ğ½)
properties of

âˆ’ ğ½# ğ½

â€¢ symmetric
â€¢ idempotent: ğ¼ â€“ ğ½# ğ½

projector [ğ¼ â€“ ğ½# ğ½]

Q

= ğ¼ â€“ ğ½# ğ½

â€¢ ğ¼ â€“ ğ½# ğ½ # = ğ¼ â€“ ğ½# ğ½
â€¢ ğ½# ğ‘ŸÌ‡ is orthogonal to [ğ¼ â€“ ğ½# ğ½]ğ‘Ì‡ 7
even more in generalâ€¦

ğ¾M , ğ¾2 generalized
ğ‘Ì‡ = ğ¾M ğ‘ŸÌ‡ + ğ¼ âˆ’ ğ¾Q ğ½ ğ‘Ì‡ 7
inverses of ğ½
... but with less nice properties! ( ğ½ğ¾V ğ½ = ğ½)
Robotics 2

how do we choose ğ‘Ì‡ 0?
26

Geometric view on Jacobian null space
in the space of velocity commands

...its projection
in the
null space

minimum norm
solution

0

final
solution

ğ‘Ì‡ 7

.

final
solution
(closest
to ğ‘Ì‡ 7 )

generic/preferred
joint velocity...

null space
correction
subspace

ğ“(J)

0
a correction is added to the original pseudoinverse (minimum norm) solution
i) which is in the null space of the Jacobian
ii) and possibly satisfies additional criteria or objectives
Robotics 2

27

Linear-Quadratic Optimization
generalities

ğ‘¥ âˆˆ â„[
ğ‘Š > 0 (symmetric)

1
min ğ» ğ‘¥ = ğ‘¥ âˆ’ ğ‘¥7 A ğ‘Š ğ‘¥ âˆ’ ğ‘¥7
n
2
ğ‘€Ã—ğ‘

s.t.

ğ‘¦ âˆˆ â„X
rank ğ½ = ğœŒ(ğ½) = ğ‘€

ğ½ğ‘¥ = ğ‘¦

ğ¿ ğ‘¥, ğœ† = ğ» ğ‘¥ + ğœ†A (ğ½ğ‘¥ âˆ’ ğ‘¦)
necessary
conditions
+
sufficient
condition
for a minimum

ğœ•ğ¿
âˆ‡n ğ¿ =
ğœ•ğ‘¥

A

ğœ•ğ¿
âˆ‡â€ ğ¿ =
ğœ•ğœ†

A

= ğ‘Š ğ‘¥ âˆ’ ğ‘¥7 + ğ½A ğœ† = 0
= ğ½ğ‘¥ âˆ’ ğ‘¦ = 0

ğ‘¥ = ğ‘¥7 âˆ’ ğ‘Š LM ğ½A ğœ†

ğ½ğ‘¥7 âˆ’ ğ½ğ‘Š LM ğ½A ğœ† âˆ’ ğ‘¦ = 0

âˆ‡Qn ğ¿ = ğ‘Š > 0

ğœ† = ğ½ğ‘Š LM ğ½A
Robotics 2

Lagrangian (with multipliers ğœ†)

LM

ğ½ğ‘¥7 âˆ’ ğ‘¦

ğ‘€Ã—ğ‘€ invertible

ğ‘¥ = ğ‘¥7 + ğ‘Š LM ğ½A ğ½ğ‘Š LM ğ½A

LM

ğ‘¦ âˆ’ ğ½ğ‘¥7
28

Linear-Quadratic Optimization
application to robot redundancy resolution

PROBLEM

SOLUTION

1
min ğ» ğ‘Ì‡ = ğ‘Ì‡ âˆ’ ğ‘Ì‡ 7 A ğ‘Š ğ‘Ì‡ âˆ’ ğ‘Ì‡ 7
uÌ‡
2
s.t. ğ½ğ‘Ì‡ = ğ‘ŸÌ‡
ğ‘Ì‡ = ğ‘Ì‡ 7 + ğ‘Š LM ğ½A ğ½ğ‘Š LM ğ½A

LM

ğ‘Ì‡ 7 is a

â€œprivilegedâ€
joint velocity

ğ‘ŸÌ‡ âˆ’ ğ½ğ‘Ì‡ 7

#
ğ½R

ğ‘Ì‡ =

#
ğ½R ğ‘ŸÌ‡

+ ğ¼

minimum weighted norm
solution (for ğ‘Ì‡ 7 = 0)
Robotics 2

#
âˆ’ ğ½R ğ½

ğ‘Ì‡ 7

â€œprojectionâ€ matrix in
the null-space ğ’©(ğ½)
29

Projected Gradient (PG)
ğ‘Ì‡ = ğ½# ğ‘ŸÌ‡ + ğ¼ âˆ’ ğ½# ğ½ ğ‘Ì‡ 7
the choice ğ‘Ì‡ 7 = âˆ‡u ğ» ğ‘ Â® differentiable objective function
realizes one step of a constrained optimization algorithm
while executing the time-varying task ğ‘Ÿ(ğ‘¡)
the robot tries to increase the value of ğ»(ğ‘)
ğ‘3
projected
gradient

ğ‘
ğ‘†u
ğ‘1

Robotics 2

âˆ‡u ğ»

for a fixed ğ‘ŸËœ: ğ‘†u = {ğ‘ âˆˆ â„ğ‘: ğ‘“ ğ‘ = ğ‘ŸÌ… }

â‡’ ğ‘Ì‡ = ğ¼ âˆ’ ğ½# ğ½ âˆ‡u ğ»
ğ‘Q ğ‘-dimensional ğ¼ âˆ’ ğ½# ğ½ âˆ‡ ğ» = 0
u
is a necessary condition
of constrained optimality

30

Typical objective functions H(q)
n

manipulability

(maximize the â€œdistanceâ€ from singularities)

ğ»â„¢Å¡â€º (ğ‘) =
n

joint range

ğ‘V âˆˆ ğ‘Â¥,V , ğ‘X,V
ğ‘X,V + ğ‘Â¥,V
ğ‘ËœV =
2
n

(minimize the â€œdistanceâ€ from the mid points of the joint ranges)
[

ğ»Å¸Å¡â€º

1
ğ‘V âˆ’ ğ‘Â¤V
Â¢
Â¡ (ğ‘) =
2ğ‘
ğ‘X,V âˆ’ ğ‘Â¥,V

Robotics 2

Q

ğ‘Ì‡ 7 = âˆ’ âˆ‡u ğ»(ğ‘)

VÂ£M

obstacle avoidance
also known as
â€œclearanceâ€

det ğ½(ğ‘)ğ½A (ğ‘)

(maximize the minimum distance to Cartesian obstacles)

ğ»Â¦Â§Â¨ (ğ‘) =

min

I âˆˆ Å¸Â¦Â§Â¦Â©
J âˆˆ Â¦Â§Â¨Â©Å¡ÂªÂ«Â¡Â¨

ğ‘ ğ‘ âˆ’ğ‘

Q

potential difficulties due
to non-differentiability
(this is a max-min problem)

31

Singularities of planar 3R arm
the robot is redundant
for a positioning task
in the plane (ğ‘€ = 2)

ğ» ğ‘ =

sinQ ğ‘Q

+

sinQ ğ‘Â®

unconstrained
maxima of
ğ»(ğ‘)

ğ»(ğ‘)

p

ğ‘2
ğ‘3

p -p

links of equal (unit) length
Robotics 2

iso-level curves of ğ»(ğ‘)

ğ‘3

p
-p

this ğ» is not ğ» man
but has the same minima

ğ‘3
ğ‘2

-p
-p

ğ‘2

p

independent from ğ‘1!
32

Minimum distance computation
in human-robot interaction

LWR4 robot with
a finite number of
control points ğ’‚(ğ’’)
(8, including the E-E)

a Kinect sensor monitors
the workspace giving the
3D position of points ğ’ƒ
on obstacles that are
fixed or moving
(like humans)

distances in 3D (and then the clearance)
are computed in this case as

min

I âˆˆ ÂªÂ¦â€ºÂ©Å¸Â¦Â« Â²Â¦Â³â€ºÂ©Â¨
J âˆˆ Â´Âµâ„¢Å¡â€º Â§Â¦Â¶Â·

Robotics 2

ğ‘ ğ‘ âˆ’ğ‘

Q

33

Comments on null-space methods
n

n

the projection matrix (ğ¼ â€“ ğ½# ğ½) has dimension ğ‘Ã—ğ‘ , but only rank ğ‘ âˆ’ ğ‘€
(if ğ½ is full rank ğ‘€ ), with some waste of information
actual (efficient) evaluation of the solution

ğ‘Ì‡ = ğ½# ğ‘ŸÌ‡ + ğ¼ âˆ’ ğ½# ğ½ ğ‘Ì‡ 7 = ğ‘Ì‡ 7 + ğ½# ğ‘ŸÌ‡ âˆ’ ğ½ğ‘Ì‡ 7
but the pseudoinverse is needed anyway, and this is computationally
intensive (SVD in the general case)
n

n

in principle, the additional complexity of a redundancy resolution method
should depend only on the redundancy degree ğ‘â€“ ğ‘€
a constrained optimization method is available, which is known to be more
efficient than the projected gradient (PG) â€”at least when the Jacobian
has full rank â€¦

Robotics 2

34

Decomposition of joint space
n

if r ğ½ ğ‘ = ğ‘€ , there exists a decomposition of the set of joints
ğ‘€Ã—ğ‘€
(possibly, after a reordering)

ğ‘I
ğ‘= ğ‘
J
n

ğ‘€
ğ‘âˆ’ğ‘€

ğœ•ğ‘“
such that ğ½I (ğ‘) =
is nonsingular
ğœ•ğ‘I

from the implicit function theorem, there exists an inverse function ğ‘”
ğ‘“ ğ‘ğ‘ , ğ‘ğ‘ = ğ‘Ÿ
ğœ•ğ‘”
ğœ•ğ‘“
=âˆ’
with
ğœ•ğ‘J
ğœ•ğ‘I

n

n

ğ‘ğ‘ = ğ‘”(ğ‘Ÿ, ğ‘ğ‘)
LM

ğœ•ğ‘“
= âˆ’ğ½ILM (ğ‘)ğ½J (ğ‘)
ğœ•ğ‘J

the ğ‘ âˆ’ ğ‘€ variables ğ‘ğ‘ can be selected independently (e.g., they are
used for optimizing an objective function ğ»(ğ‘), â€œreducedâ€ via the use
of ğ‘” to a function of ğ‘ğ‘ only)

ğ‘ğ‘ = ğ‘”(ğ‘Ÿ, ğ‘ğ‘) is then chosen so as to correctly execute the task

Robotics 2

35

Reduced Gradient (RG)
n
n

ğ»(ğ‘) = ğ»(ğ‘ğ‘, ğ‘J ) = ğ»(ğ‘”(ğ‘Ÿ, ğ‘J ), ğ‘ğ‘) = ğ»â€²(ğ‘ğ‘), with ğ‘Ÿ at current value
the Reduced Gradient (w.r.t. ğ‘ğ‘ only, but still keeping the effects of this
choice into account) is
Âº
Âº

âˆ‡u Â¹ ğ» = âˆ’

ğ½ILM ğ½J A

ğ¼[LX âˆ‡u ğ»

(â‰  âˆ‡uÂ¹ ğ» only!!)
n

algorithm

ğ‘Ì‡ J = âˆ‡uÂ¹ ğ» Âº
ğ½I ğ‘Ì‡ I + ğ½J ğ‘Ì‡ J = ğ‘ŸÌ‡

âˆ‡u Â¹ ğ» = 0

is a â€œcompactâ€
(i.e., ğ‘ âˆ’ ğ‘€ dimensional)
necessary condition
of constrained optimality

step in the gradient direction of
the reduced (ğ‘ âˆ’ ğ‘€)-dim space
satisfaction of the ğ‘€ -dim
task constraints

ğ‘Ì‡ I = ğ½ILM ğ‘ŸÌ‡ âˆ’ ğ½J ğ‘Ì‡ J
Robotics 2

36

Comparison between PG and RG
n

Projected Gradient (PG)
ğ‘Ì‡ = ğ½# ğ‘ŸÌ‡ + ğ¼ âˆ’ ğ½# ğ½ âˆ‡u ğ»

n

Reduced Gradient (RG)
LM
LM ğ½
ğ‘Ì‡ I
ğ½
âˆ’ğ½
I J
ğ‘Ì‡ =
= I ğ‘ŸÌ‡ +
ğ‘Ì‡ J
0
ğ¼

n

n

n

âˆ’ ğ½ILM ğ½J

A

ğ¼ âˆ‡u ğ»

RG is analytically simpler and numerically faster than PG, but
requires the search for a non-singular minor (ğ½I ) of the robot
Jacobian
if ğ‘Ÿ = cost & ğ‘ âˆ’ ğ‘€ = 1 â‡’ same (unique) direction for ğ‘Ì‡ , but
RG has automatically a larger optimization step size
else â‡’ RG and PG methods provide always different evolutions

Robotics 2

37

Analytic comparison
PPR robot

1
ğ½=
0

ğ‘™
ğ‘3
ğ‘1

0
1

âˆ’ğ‘™ğ‘ Â®
= ğ½I
ğ‘™ğ‘Â®

LM
LM
ğ‘Ì‡ = ğ½I ğ‘ŸÌ‡ + âˆ’ğ½I ğ½J
0
ğ¼

RG:

1
ğ‘Ì‡ = 0
0

ğ‘2

ğ½J

ğ‘M
ğ‘I = ğ‘
Q

ğ‘™ğ‘ Â®
0
1 ğ‘ŸÌ‡ + âˆ’ğ‘™ğ‘Â®
0
1

ğ‘™ğ‘ Â®

ğ‘J = ğ‘Â®

âˆ’ ğ½ILM ğ½J

A

ğ¼ âˆ‡u ğ»

âˆ’ğ‘™ğ‘Â®

1 âˆ‡u ğ»

ğ‘™ Q ğ‘ Â® ğ‘Â®
ğ‘™ Q ğ‘Â®Q
âˆ’ğ‘™ğ‘Â®

ğ‘™ğ‘ Â®
âˆ’ğ‘™ğ‘Â®
1

PG: ğ‘Ì‡ = ğ½# ğ‘ŸÌ‡ + ğ¼ âˆ’ ğ½# ğ½ âˆ‡u ğ»

1
#
ğ½ =
1 + ğ‘™Q

Robotics 2

1 + ğ‘™ Q ğ‘Â®Q
ğ‘™ Q ğ‘ Â® ğ‘Â®
âˆ’ğ‘™ğ‘ Â®

ğ‘™ Q ğ‘ Â® ğ‘Â®
1 + ğ‘™ Q ğ‘ Â®Q
ğ‘™ğ‘Â®

1
#
ğ¼âˆ’ğ½ ğ½=
1 + ğ‘™Q

ğ‘™ Q ğ‘ Â®Q
ğ‘™ Q ğ‘ Â® ğ‘Â®
ğ‘™ğ‘ Â®

always < 1!!

38

Joint range limits
0
1
1
1

0
0
1
1

âˆ’90Â° â‰¤ ğœƒV â‰¤ 90Â°

0
0 ğœƒ = ğ‘‡ğœƒ
0
1

â‡”

1
ğ‘= 1
1
1

âˆ’90Â° â‰¤ ğ‘V âˆ’ ğ‘VLM â‰¤ 90Â°

absolute â‡” relative
coordinates
ğœƒ=

1
0
âˆ’1
1
0 âˆ’1
0
0

0 0
0 0 ğ‘ = ğ‘‡ LM ğ‘
1 0
âˆ’1 1

G
ğ‘2

task:
E-E linear path
from S to G

S

initial configuration

ğ‘4

ğ‘1

numerical comparison among pseudoinverse (PS),
projected gradient (PG), and reduced gradient (RG) methods
Robotics 2

39

Numerical results

minimizing distance from mid joint range

joint 1

joint 3

joint 2

joint 4

upper
limit

steps of numerical simulation
Robotics 2

40

Numerical results

self-motion for escaping singularities
Â®

(optimal)

max ğ» ğ‘ =

Â¢ sinQ
VÂ£M

ğ‘ŸÂº0

ğ‘V@M âˆ’ ğ‘V

this function is NOT
the manipulability index,
but has the same minima (= 0)

(almost singular)

8.

steps of numerical simulation

RG is faster than PG
(keeping the same accuracy on ğ‘Ÿ)
Robotics 2

41

3
n

Task augmentation methods

an auxiliary task is added (task augmentation)
ğ‘†

ğ‘“Ã‚ (ğ‘) = ğ‘¦

ğ‘† â‰¤ ğ‘âˆ’ğ‘€

corresponding to some desirable feature for the solution
ğ‘Ÿ
ğ‘“(ğ‘)
ğ‘ŸÃ„ = ğ‘¦ =
ğ‘“Ã‚ (ğ‘)
n

ğ½(ğ‘)
ğ‘ŸÃ„Ì‡ =
ğ‘Ì‡ = ğ½Ã„ (ğ‘)ğ‘Ì‡
ğ½Ã‚ (ğ‘)

ğ½ğ´

ğ‘€+ğ‘†

ğ‘

a solution is chosen still in the form of a generalized inverse

ğ‘Ì‡ = ğ¾Ã„ (ğ‘)ğ‘ŸÃ„Ì‡
or by adding a term in the null space of the augmented
Jacobian matrix ğ½ğ´
Robotics 2

42

Augmenting the task â€¦
n

advantage: better shaping of the inverse kinematic solution

n

disadvantage: algorithmic singularities are introduced when
r(ğ½) = ğ‘€

r(ğ½Ã‚ ) = ğ‘†

but

to avoid this, it should be always

r(ğ½Ã„ ) < ğ‘€ + ğ‘†

â„› ğ½A âˆ© â„› ğ½Ã‚A = âˆ…

difficult to be obtained globally!
rows of ğ½ AND rows of ğ½ğ‘¦
are all together linearly independent

Robotics 2

43

Augmented task
example

ğ‘Ÿ(ğ‘¡)
ğ‘ = 4, ğ‘€ = 2

absolute joint coordinates

ğ‘“Ã‚ (ğ‘) = ğ‘Ãˆ = p/2

(ğ‘† = 1)

last link is to be held verticalâ€¦
Robotics 2

44

Extended Jacobian (ğ‘† = ğ‘-ğ‘€)
n

square ğ½ğ´: in the absence of algorithmic singularities, we can choose

ğ‘Ì‡ = ğ½Ã„LM (ğ‘)ğ‘ŸÃ„Ì‡
n

the scheme is then repeatable
n

n

n

provided no singularities are encountered during a complete task cycle*

when the ğ‘ âˆ’ ğ‘€ conditions ğ‘“Ã‚ (ğ‘) = 0 correspond to necessary (and
sufficient) conditions for constrained optimality of a given objective
function ğ»(ğ‘) (see RG method, slide #36), this scheme guarantees that
constrained optimality is locally preserved during task execution
in the vicinity of algorithmic singularities, the execution of both the
original task as well as the auxiliary task(s) are affected by errors
(when using DLS inversion)

* there exists an unexpected phenomenon in some 3R manipulators having â€œgenericâ€ kinematics: the robot may sometimes perform a pose

change after a full cycle, even if no singularity has been encountered during motion (see J. Burdick, Mech. Mach. Theory, 30(1), 1995)

Robotics 2

45

Extended Jacobian
example

MACRO-MICRO manipulator
ğ‘Ÿ(ğ‘¡)
ğ‘¦(ğ‘¡)

ğ‘ = 4, ğ‘€ = 2

ğ‘ŸÌ‡ = ğ½(ğ‘M , â€¦ , ğ‘Ãˆ )ğ‘Ì‡
ğ‘¦Ì‡ = ğ½Ã‚ (ğ‘M , ğ‘Q )ğ‘Ì‡

âˆ— âˆ—
ğ½Ã„ =
âˆ— 0

Robotics 2

4Ã—4

46

Task Priority
if the original (primary) task ğ‘ŸMÌ‡ = ğ½M (ğ‘)ğ‘Ì‡ has higher priority
than the auxiliary (secondary) task ğ‘ŸQÌ‡ = ğ½Q (ğ‘)ğ‘Ì‡
n

we first address the task with highest priority

ğ‘Ì‡ = ğ½M# ğ‘ŸMÌ‡ + ğ¼ âˆ’ ğ½M# ğ½M ğ‘£M
n

and then choose ğ‘£M so as to satisfy, if possible, also the secondary
(lower priority) task
ğ‘ŸQÌ‡ = ğ½Q ğ‘Ì‡ = ğ½Q ğ½M# ğ‘ŸMÌ‡ + ğ½Q ğ¼ âˆ’ ğ½M# ğ½M ğ‘£M = ğ½Q ğ½M# ğ‘ŸMÌ‡ + ğ½Q ğ‘ƒM ğ‘£M
the general solution for ğ‘£M takes the usual form

ğ‘£M = ğ½Q ğ‘ƒM

#

ğ‘ŸQÌ‡ âˆ’ ğ½Q ğ½M# ğ‘ŸMÌ‡ + ğ¼ âˆ’ ğ½Q ğ‘ƒM

#

ğ½Q ğ‘ƒM

ğ‘£Q

ğ‘£Q is available for the execution of further tasks of lower (ordered) priorities
Robotics 2

47

Task Priority

(continue)

Â§ substituting the expression of ğ‘£M in ğ‘Ì‡

ğ‘Ì‡ = ğ½M# ğ‘ŸMÌ‡ + ğ‘ƒM ğ½Q ğ‘ƒM
= ğµğ‘ƒ #
when matrix ğ‘ƒ is

ğ‘ƒ ğµğ‘ƒ

#

idempotent and symmetric

#

ğ‘ŸQÌ‡ âˆ’ ğ½Q ğ½M# ğ‘ŸMÌ‡ + ğ‘ƒM ğ¼ âˆ’ ğ½Q ğ‘ƒM

= ğ½Q ğ‘ƒM

#

#

ğ½Q ğ‘ƒM

ğ‘£Q

possibly = 0

Â§ main advantage: highest priority task is ideally no longer affected
by algorithmic singularities (error is restricted only to secondary task)

task 1: follow â€”

WITHOUT
task priority

WITH
task priority

task 2: vertical
third link

Robotics 2

48

