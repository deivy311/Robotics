Robotics 2

Robots with
kinematic redundancy
Part 2: Extensions
Prof. Alessandro De Luca

A general task priority formulation
n

n

n

consider a large number ğ‘ of tasks to be executed at best and with
strict priorities by a robotic system having many dofs
everything should run efficiently in real time, with possible addition,
deletion, swap, or reordering of tasks
a recursive formulation that reduces computations is convenient

ğ‘˜-th task

projector in the null-space of ğ‘˜-th task

(

)

even larger!
projector in the null-space of the
augmented Jacobian of the first ğ‘˜ tasks

stack of first ğ‘˜ tasks

Robotics 2

augmented Jacobian
of first ğ‘˜ tasks

2

Recursive solution with priorities
n

-1

start with the first task and reformulate the problem so as to provide
always a â€œsolutionâ€, at least in terms of minimum error norm

Robotics 2

3

Recursive solution with priorities

prioritized solution
up to task ğ‘˜ âˆ’ 1

-2

set of all solutions up to task ğ‘˜ âˆ’ 1

LQ problem
for ğ‘˜-th task
initialization

recursive formula
(Siciliano, Slotine:
ICAR 1991)

prioritized
solution
up to task ğ‘˜

correction needed when
the solution up to task ğ‘˜ âˆ’ 1
is not satisfying also task ğ‘˜

over the steps, the search set
is progressively reduced

Robotics 2

4

Recursive solution with priorities
properties and implementation

n

the solution considering the first ğ‘˜ tasks with their priority
satisfies also (â€œdoes not perturbâ€) the previous ğ‘˜ âˆ’ 1 tasks
since
=
(Maciejewski, Klein: IJRR 1985): check the four defining properties of a pseudoinverse

n

recursive expression also for the null-space projector

(Baerlocher, Boulic: IROS 1998): for the proof, see Appendix A
n

when the ğ‘˜-th task is (close to be) incompatible with the previous ones
(algorithmic singularity), use â€œDLSâ€ instead of â€œ#â€ in ğ‘˜-th solution...

Robotics 2

5

A list of extensions
(some still on-going research)

n

up to now, only â€œbasicâ€ redundancy resolution schemes
n

defined at first-order differential level (velocity)
n it is possible to work in acceleration
n
n

n

n

n

seen within a planning, not a control perspective
n take into account and recover errors in task execution by
using kinematic control schemes
applied to robot manipulators with fixed base
n extend to wheeled mobile manipulators
tasks specified only by equality constraints
n add also linear inequalities in a complete QP formulation
n

n

Robotics 2

useful for obtaining smoother motion
allows including the consideration of dynamics

very common also for humanoid robots in multiple tasks

consider hard limits in joint/command space
6

Resolution at acceleration level
ğ‘Ÿ = ğ‘“(ğ‘)
n

ğ‘ŸÌ‡ = ğ½(ğ‘)ğ‘Ì‡

Ì‡ ğ‘Ì‡
ğ‘ŸÌˆ = ğ½ ğ‘ ğ‘Ìˆ + ğ½(ğ‘)

rewritten in the form
Ì‡ ğ‘Ì‡ â‰œ ğ‘¥Ìˆ
ğ½ ğ‘ ğ‘Ìˆ = ğ‘ŸÌˆ âˆ’ ğ½(ğ‘)
to be chosen

n

given
(at time ğ‘¡)

known ğ‘, ğ‘Ì‡
(at time ğ‘¡)

the problem is formally equivalent to the previous one,
with acceleration in place of velocity commands
for instance, in the null-space method
ğ‘Ìˆ = ğ½# ğ‘ ğ‘¥Ìˆ + ğ¼ âˆ’ ğ½# ğ‘ ğ½(ğ‘) ğ‘Ìˆ :
solution with minimum
acceleration norm ğ‘Ìˆ *

Robotics 2

= âˆ‡< ğ» âˆ’ ğ¾, ğ‘Ì‡

needed
to damp/stabilize
self-motions
in the null space
(ğ¾, > 0)
7

Dynamic redundancy resolution
n

dynamic model of a robot manipulator (more later!)
ğ‘€ ğ‘ ğ‘Ìˆ + ğ‘› ğ‘, ğ‘Ì‡ = ğœ
ğ½(ğ‘)ğ‘Ìˆ = ğ‘¥Ìˆ (= ğ‘ŸÌˆ âˆ’ ğ½ Ì‡ ğ‘ ğ‘)
Ì‡

ğ‘Ã—ğ‘ symmetric

inertia matrix,
positive definite for all ğ‘

input torque vector
ğ‘€-dimensional
(provided by the motors) acceleration task

Coriolis/centrifugal vector ğ‘(ğ‘, ğ‘)
Ì‡
+ gravity vector ğ‘”(ğ‘)
n

n

(Â°)

we can formulate and solve interesting dynamic
problems in the general framework of LQ optimization(Â°)
closed-form expressions can be obtained by the solution
formula(Â°) (assuming a full rank Jacobian ğ½)
in block Kinematic redundancy - Part 1, slide #26

Robotics 2

8

Dynamic redundancy resolution
as Linear-Quadratic optimization problems

n

typical dynamic objectives to be locally minimized at (ğ‘, ğ‘)
Ì‡
torque norm
1
ğ»E ğ‘Ìˆ =
ğœ
2

*

1 G *
1 G
G
= ğ‘Ìˆ ğ‘€ ğ‘ ğ‘Ìˆ + ğ‘› ğ‘, ğ‘Ì‡ ğ‘€ ğ‘ ğ‘Ìˆ + ğ‘› ğ‘, ğ‘Ì‡ ğ‘› ğ‘, ğ‘Ì‡
2
2

(squared inverse inertia weighted) torque norm
1
1 G K*
*
ğ»* ğ‘Ìˆ =
ğœ H IJ = ğœ ğ‘€ ğ‘ ğœ
2
2
1 G
1 G
G
KE
= ğ‘Ìˆ ğ‘Ìˆ + ğ‘› ğ‘, ğ‘Ì‡ ğ‘€ (ğ‘)ğ‘Ìˆ + ğ‘› ğ‘, ğ‘Ì‡ ğ‘€K* (ğ‘)ğ‘› ğ‘, ğ‘Ì‡
2
2
(inverse inertia weighted) torque norm
1
1 G KE
*
ğ»L ğ‘Ìˆ =
ğœ H IM = ğœ ğ‘€ ğ‘ ğœ
2
2
1 G
1 G
G
= ğ‘Ìˆ ğ‘€ ğ‘ ğ‘Ìˆ + ğ‘› ğ‘, ğ‘Ì‡ ğ‘Ìˆ + ğ‘› ğ‘, ğ‘Ì‡ ğ‘€KE (ğ‘)ğ‘› ğ‘, ğ‘Ì‡
2
2
Robotics 2

9

Closed-form solutions
1
ğœ
2

minimum torque norm solution

ğœE = ğ½ ğ‘ ğ‘€ KE (ğ‘)

*

#

ğ‘ŸÌˆ âˆ’ ğ½ Ì‡ ğ‘ ğ‘Ì‡ + ğ½ ğ‘ ğ‘€ KE ğ‘ ğ‘›(ğ‘, ğ‘)
Ì‡

â€¢ good for short trajectories (in fact, it is still only a â€œlocalâ€ solution!)
â€¢ for longer trajectories it leads to torque â€œoscillation/explosionâ€ (whipping effect)
1
ğœ
2

minimum (squared inverse inertia weighted) torque norm solution
*
HIJ

ğœ* = ğ‘€(ğ‘)ğ½# (ğ‘) ğ‘ŸÌˆ âˆ’ ğ½ Ì‡ ğ‘ ğ‘Ì‡ + ğ½ ğ‘ ğ‘€ KE ğ‘ ğ‘›(ğ‘, ğ‘)
Ì‡

â€¢ good performance in general, to be preferred

minimum (inverse inertia weighted) torque norm solution
1
ğœ
2

*
HIM

ğœL = ğ½G (ğ‘) ğ½ ğ‘ ğ‘€ KE (ğ‘)ğ½G (ğ‘)

KE

ğ‘ŸÌˆ âˆ’ ğ½ Ì‡ ğ‘ ğ‘Ì‡ + ğ½ ğ‘ ğ‘€ KE ğ‘ ğ‘›(ğ‘, ğ‘)
Ì‡

â€¢ a solution with a leading ğ½ğ‘‡(ğ‘) term: what is its nice physical interpretation?

May we add terms in a (dynamic) null space? Easy to do in the LQ framework!
Robotics 2

10

Stabilizing the minimum torque solution
video
Universal
Robots
UR-10
(6-dof)
video
KUKA
LRW 4
(7-dof,
last joint
not used)

min

E
*

ğœ

*

= MTN

versus
â€¢ MBP = minimizing
torque also at a short
preview instant
â€¢ MTND = damping
joint velocity in the
null space
â€¢ MBPD = â€¦ do both
IEEE Robotics and
Automation Lett. 2019

Robotics 2

11

Kinematic control
n

given a desired ğ‘€-dimensional task ğ‘ŸO (ğ‘¡), in order to recover
a task error ğ‘’ = ğ‘ŸO â€“ ğ‘Ÿ due to initial mismatch or due to
n
n
n

disturbances
inherent linearization error in using the Jacobian (first-order motion)
discrete-time implementation

we need to â€œcloseâ€ a feedback loop on task execution, by
replacing (with diagonal matrix gains ğ¾ > 0 or ğ¾R , ğ¾, > 0)
ğ‘ŸÌ‡

ğ‘ŸOÌ‡ + ğ¾ ğ‘ŸO âˆ’ ğ‘Ÿ

ğ‘ŸÌˆ

ğ‘ŸOÌˆ + ğ¾, ğ‘ŸOÌ‡ âˆ’ ğ‘ŸÌ‡ + ğ¾R ğ‘ŸO âˆ’ ğ‘Ÿ

in velocity-based...
â€¦in acceleration-based methods

where ğ‘Ÿ = ğ‘“ ğ‘ , ğ‘ŸÌ‡ = ğ½(ğ‘)ğ‘Ì‡
Robotics 2

12

Mobile manipulators
n
n

coordinates: ğ‘S of the base and ğ‘T of the manipulator
differential map: from available commands ğ‘¢S on the mobile
base and ğ‘¢T on the manipulator to task output velocity
ğ‘Ÿ = ğ‘“ ğ‘ âˆˆ â„H
ğ‘T

(task output, e.g.,
the E-E pose)

ğ‘S
ğ‘Ì‡ S = ğº(ğ‘S )ğ‘¢S
Z
ğ‘= ğ‘
âˆˆâ„
ğ‘Ì‡ T = ğ‘¢T
T
ğ‘S
Robotics 2

ğ‘¢S
ğ‘¢= ğ‘¢
âˆˆ â„Z[
T

kinematic
model of the
wheeled base
(subject to
nonholonomic
constraints)

ğ‘X â‰¤ ğ‘
13

Mobile manipulator Jacobian
ğ‘Ÿ = ğ‘“ ğ‘ = ğ‘“(ğ‘S , ğ‘T )
ğœ•ğ‘“(ğ‘)
ğœ•ğ‘“(ğ‘)
ğ‘ŸÌ‡ =
ğ‘Ì‡ S +
ğ‘Ì‡ T = ğ½S ğ‘ ğ‘Ì‡ S + ğ½T ğ‘ ğ‘Ì‡ T
ğœ•ğ‘S
ğœ•ğ‘T
= ğ½S ğ‘ ğº(ğ‘S )ğ‘¢S + ğ½T ğ‘ ğ‘¢T = ğ½S (ğ‘)ğº(ğ‘S )
= ğ½ZHH ğ‘ ğ‘¢
n

ğ½T (ğ‘)

ğ‘¢S
ğ‘¢T

Nonholonomic Mobile Manipulator (NMM)
Jacobian (ğ‘€Ã—ğ‘X )

â€¦ most previous results follow by just replacing
ğ½ âŸ¹ ğ½ZHH

ğ‘Ì‡ âŸ¹ ğ‘¢

(redundancy if ğ‘X âˆ’ ğ‘€ > 0)

namely, the
available velocity commands
Robotics 2

14

Mobile manipulators
video

Automatica Fair 2008
video

car-like+2R planar arm
(ğ‘ = 6, ğ‘X = 4):
E-E trajectory control on a line (ğ‘X âˆ’ ğ‘€ = 2)
with maximization of ğ½ZHH manipulability
Robotics 2

wheeled Justin with centered
steering wheels
(ğ‘ = 3 + 4Ã—2, ğ‘X = 8)
â€œdancingâ€ in controlled
but otherwise passive mode

15

Quadratic Programming (QP)
with equality and inequality constraints

n

minimize a quadratic objective function (typically positive definite, like when
using norms of vectors) subject to linear equality and inequality constraints,
all expressed in terms of joint velocity commands

solution set, with only equality constraints

within a given convex set

QP complete formulation
solution set, with only inequality constraints

(non-negative) slack variables

Robotics 2

(possibly with prioritization
of constraints)

16

Equality and inequality linear constraints
higher priority â‰» lower priority
feasible convex area
(from inequalities)

active
inequality
constraint

solution if
ineq â â‰» ineq â‘ 

inequality â‘ 

inequality
constraint

solution if
ineq â‘  â‰» ineq â
minimum norm
solution

any priority order
gives the same
final solution

feasible convex area
equality
constraint

inequality â
NO exact
solution here

NO exact
solution here
set of possible
minimum error
solutions if ...

inequality â€

equality

... equality â‰» inequalities
inequality â
... inequalities â‰» equality

slack variables
E
minimizing * ğ’˜ *

inequality â‘ 
solution if
{ineq â‘  , ineq â}
â‰» equality

ğ‘¤E = ğ‘¤*

solution if equality
â‰» {ineq â‘  , ineq â}

feasible convex area
inequality â‚

equality

feasible convex area

Robotics 2

equality
(top priority)

inequality â

17

Equality and Inequality Tasks

6R planar robot (simulations) and 7R KUKA LWR (experiment)
n

an efficient task priority approach, with simultaneous inequality tasks
handled as hard (cannot be violated) or soft (can be relaxed) constraints
video

IEEE/RSJ Int. Conf. on Intelligent Robots and Systems (IROS) 2015
Robotics 2

18

Equality and Inequality Tasks
for the high-dof humanoid robot HRP2

n

a systematic task priority approach, with several simultaneous tasks

video

in any order of priority
â€¢ avoid the obstacle
â€¢ gaze at the object
â€¢ reach the object
â€¢ ...
while keeping balance!

IEEE Int. Conf. on Robotics and Automation (ICRA) 2009
Robotics 2

all subtasks are locally
expressed by linear
equalities or inequalities
(possibly relaxed
when needed)
on joint velocities
19

Inclusion of hard limits in joint space
Saturation in the Null Space (SNS) method

n

n

n

n

n

n

robot has â€œlimitedâ€ capabilities: hard limits on joint ranges and/or on joint
motion or commands (max velocity, acceleration, torque)
represented as box inequalities that can never be violated (at most, active
constraints or saturated commands) â€“ kept separated from â€œstackâ€ of tasks
(equality) tasks are usually executed in full (with priorities, if desired), but
can be relaxed (scaled) in case of need (i.e., when robot capabilities are used
at their limits)
saturate one overdriven joint command at a time, until a feasible and better
performing solution is found â‡’ Saturation in the Null Space = SNS
on-line decision: which joint commands to saturate and how, so that this
does not affect task execution
for tasks that are (certainly) not feasible, SNS embeds the selection of a task
scaling factor preserving execution of the task direction with minimal scaling

Robotics 2

scaling
factor

diagonal
0/1 matrix

contains
saturated
joint
velocities
20

Geometric view on SNS operation
in the space of velocity commands
NO exact
solution here

=

=

hard bounds
(box inequality constraints)

hard bounds
(box inequality constraints)

the total correction to the original pseudoinverse solution
is always in the null space of the Jacobian (up to task scaling, if present)
Robotics 2

21

Illustrative example

-1

consider a 4R robot with equal links of unitary length
task: end-effector Cartesian position
manipulator configuration
differential map

task Jacobian

desired Cartesian velocity
commanded joint velocity

velocity limits
Robotics 2

22

Illustrative example

-2

current configuration
associated Jacobian
desired end-effector velocity

2.0

-2.0

direct (velocity =) task scaling?

saturating only the most violating velocity?

[
Robotics 2

]
23

Joint velocity bounds
joint velocity bounds

joint space
limits

conversion: control sampling (piece-wise constant velocity commands) + max feasible velocities
and decelerations to stay/stop within the joint range

smooth velocity bound â€œanticipatesâ€ the reaching of a hard limit

Robotics 2

24

SNS at velocity level
Algorithm 1

initialization
W : diagonal matrix with (ğ‘—, ğ‘—) element
= 1 if joint ğ‘— is enabled
= 0 if joint ğ‘— is disabled
: vector with saturated velocities in
correspondence of disabled joints
s : current task scale factor
s*: largest task scale factor so far

Robotics 2

25

SNS at velocity level
Algorithm 1

compute the joint velocity with
initialized values

check the joint velocity bounds
compute the task scaling factor
and the most critical joint
if a larger task scaling factor is
obtained, save the current solution
disable the most critical joint by
forcing it at its saturated velocity

Robotics 2

26

SNS at velocity level
Algorithm 1

check if task can be accomplished
with the remaining enabled joints
if NOT, use the parameters that
allow the largest task scaling
factor and exit
repeat until no joint limit is
exceeded
Robotics 2

27

Task scaling factor
Algorithm 2

yields the best task scaling factor
(i.e., closest to the ideal value = 1)
for the most critical joint in the
current joint velocity solution

Robotics 2

28

Simulation results
7-dof KUKA LWR IV

[deg]
[deg/s]
[deg/s2]
[ms]

Robotics 2

29

Simulation results
for increasing V
requested task
move the end-effector through six
desired Cartesian positions along
linear paths with constant speed V
Neglecting
Constraint

task redundancy degree = 7 â€“ 3 = 4
Task
Scaling

robot starts at the configuration
[deg]

SNS
approach

Robotics 2

(with a small initial approaching phase)

30

Experimental results
KUKA LWR IV with hard joint-space limits

Robotics 2

IEEE Transactions on Robotics 2015

video

31

Variations of the SNS method
SNS at the acceleration command level + consideration of multiple tasks with priority

video

IEEE/RSJ Int. Conf. on Intelligent Robots and Systems (IROS) 2012
Robotics 2

32

Bibliography
n
n
n

n

n
n

n

n

n

n

n

-1

R. Cline, â€œRepresentations for the generalized inverse of a partitioned matrix,â€ J. SIAM, pp. 588-600, 1964
T.L. Boullion, P. L. Odell, Generalized Inverse Matrices, Wiley-Interscience, 1971
A. Maciejewski, C. Klein, â€œObstacle avoidance for kinematically redundant manipulators in dynamically
varying environments,â€ Int. J. of Robotics Research, vol. 4, no. 3, pp. 109-117, 1985
A. Maciejewski, C. Klein, â€œNumerical filtering for the operation of robotic manipulators through kinematically
singular configurations,â€ J. of Robotic Systems, vol. 5, no. 6, pp. 527-552, 1988
Y. Nakamura, Advanced Robotics: Redundancy and Optimization, Addison-Wesley, 1991
B. Siciliano, J.J. Slotine, â€œA general framework for managing multiple tasks in highly redundant robotic
systems,â€ 5th Int. Conf. on Advanced Robotics, pp. 1211-1216, 1991
P. Baerlocher, R. Boulic, â€œTask-priority formulations for the kinematic control of highly redundant articulated
structuresâ€, IEEE/RSJ Int. Conf. on Intelligent Robots and Systems, pp. 323-329, 1998
P. Baerlocher, R. Boulic, â€œAn inverse kinematic architecture enforcing an arbitrary number of strict priority
levels,â€ The Visual Computer, vol. 6, no. 20, pp. 402-417, 2004
A. Escande, N. Mansard, P.-B. Wieber, â€œFast resolution of hierarchized inverse kinematics with inequality
constraints,â€ IEEE Int. Conf. on Robotics and Automation, pp. 3733-3738, 2010
O. Kanoun, F. Lamiraux, P.-B. Wieber, â€œKinematic control of redundant manipulators: Generalizing the taskpriority framework to inequality task,â€ IEEE Trans. on Robotics, vol. 27, no. 4, pp. 785-792, 2011
A. Escande, N. Mansard, P.-B. Wieber, â€œHierarchical quadratic programming: Fast online humanoid-robot
motion generation,â€ Int. J. Robotics Research, vol. 33, no, 7, pp. 1006-1028, 2014 (including software, also
in http://hal.archives-ouvertes.fr/hal-00751924, 26 Dec 2012)

Robotics 2

33

Bibliography
n

n

n

n

n

n

n

n

n

n

n

-2

A. De Luca, G. Oriolo, â€œThe reduced gradient method for solving redundancy in robot arms,â€ Robotersysteme,
vol. 7, no. 2, pp. 117-122, 1991
A. De Luca, G. Oriolo, B. Siciliano, â€œRobot redundancy resolution at the acceleration level,â€ Laboratory Robotics
and Automation, vol. 4, no. 2, pp. 97-106, 1992
A. De Luca, G. Oriolo, â€œReconfiguration of redundant robots under kinematic inversion,â€ Advanced Robotics, vol.
10, n. 3, pp. 249-263, 1996
A. De Luca, G. Oriolo, P. Robuffo Giordano, â€œKinematic control of nonholonomic mobile manipulators in the
presence of steering wheels,â€ IEEE Int. Conf. on Robotics and Automation, pp. 1792-1798, 2010
F. Flacco, A. De Luca, O. Khatib, â€œMotion control of redundant robots under joint constraints: Saturation in the
null space,â€ IEEE Int. Conf. on Robotics and Automation, pp. 285-292, 2012
F. Flacco, A. De Luca, O. Khatib, â€œPrioritized multi-task motion control of redundant robots under hard joint
constraints,â€ IEEE/RSJ Int. Conf. on Intelligent Robots and Systems, pp. 3970-3977, 2012
F. Flacco, A. De Luca, â€œOptimal redundancy resolution with task scaling under hard bounds in the robot joint
space,â€ IEEE Int. Conf. on Robotics and Automation, pp. 3969-3975, 2013
F. Flacco, A. De Luca, "Fast redundancy resolution for high-dimensional robots executing prioritized tasks under
hard bounds in the joint space,â€ IEEE/RSJ Int. Conf. on Intelligent Robots and Systems, pp. 2500-2506, 2013
F. Flacco, A. De Luca, O. Khatib, â€œControl of redundant robots under hard joint constraints: Saturation in the
null space,â€ IEEE Transactions on Robotics, vol. 31, no. 3, pp. 637-654, 2015
F. Flacco, A. De Luca, â€œUnilateral constraints in the Reverse Priority redundancy resolution method,â€ IEEE/RSJ
Int. Conf. on Intelligent Robots and Systems, pp. 2564-2571, 2015
A. Al Khudir, G. Halvorsen, L. Lanari, A: De Luca, â€œStable torque optimization for redundnat robots using a short
preview,â€ IEEE Robotics and Automation Lett., vol 4, no, 2, pp. 2046-2057, 2019

Robotics 2

34

Appendix A - Recursive Task Priority
proof of recursive expression for null-space projector

n

proof based on a result on pseudoinversion of partitioned matrices (Cline: J. SIAM 1964)

n

(i)
n

(i) + (ii) â‡’ Q.E.D.

n

if ğ‘˜ -th task is scalar
=

n

(ii)
(Greville formula)

Robotics 2

35

